#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Èõ≤Á´ØMACDÁõ£ÊéßÁ≥ªÁµ±
ÊîØÊåÅÂ§öÁ®ÆÈõ≤Á´ØÂπ≥Âè∞ÈÉ®ÁΩ≤ÂíåÈÄöÁü•ÊñπÂºè
"""

import asyncio
import json
import logging
import time
import os
from datetime import datetime, timedelta, timezone
from typing import Dict, List, Optional, Any
import schedule
import pandas as pd
import aiohttp  # Ê∑ªÂä†httpÂÆ¢Êà∂Á´Ø

from max_api import MaxAPI
from enhanced_macd_analyzer import EnhancedMACDAnalyzer
from telegram_notifier import TelegramNotifier

# Ê∑ªÂä†‰∫§‰∫íÂºèÂ§ÑÁêÜÂô®ÂØºÂÖ•
try:
    from webhook_telegram_handler import WebhookTelegramHandler
    WEBHOOK_AVAILABLE = True
except ImportError:
    WEBHOOK_AVAILABLE = False
    WebhookTelegramHandler = None

# ‰øùÁïôÂéüÊúâÁöÑÈï∑Ëº™Ë©¢ËôïÁêÜÂô®‰ΩúÁÇ∫ÂÇôÁî®
try:
    from interactive_telegram_handler import InteractiveTelegramHandler
    INTERACTIVE_AVAILABLE = True
except ImportError:
    INTERACTIVE_AVAILABLE = False
    InteractiveTelegramHandler = None

# Âè∞ÁÅ£ÊôÇÂçÄ (UTC+8)
TAIWAN_TZ = timezone(timedelta(hours=8))

class CloudMonitor:
    """Èõ≤Á´ØÁõ£ÊéßÁ≥ªÁµ±‰∏ªÈ°û"""
    
    def __init__(self, config_file: str = 'monitor_config.json'):
        self.config_file = config_file
        self.config = self.load_config()
        
        # ‰ΩøÁî®Áí∞Â¢ÉËÆäÈáèË¶ÜËìãÈÖçÁΩÆ
        self.apply_env_overrides()
        
        # ÂàùÂßãÂåñÁµÑ‰ª∂
        self.max_api = MaxAPI()
        self.macd_analyzer = EnhancedMACDAnalyzer()
        self.telegram_notifier = TelegramNotifier()
        
        # Ë®≠ÁΩÆÊó•Ë™å
        self.setup_logging()
        
        # Áõ£ÊéßÁãÄÊÖã
        self.is_running = False
        self.last_alerts = {}
        self.monitoring_data = {}
        
        # Áµ±Ë®àÊï∏Êìö
        self.stats = {
            'alerts_sent': 0,
            'checks_performed': 0,
            'errors_count': 0,
            'start_time': None
        }
        
        # ‰øùÊ¥ªÂäüËÉΩË®≠ÁΩÆ
        self.keep_alive_enabled = os.getenv('KEEP_ALIVE_ENABLED', 'true').lower() == 'true'
        self.keep_alive_interval = int(os.getenv('KEEP_ALIVE_INTERVAL', '300'))  # 5ÂàÜÈêòÔºåÁ¢∫‰øùÊúçÂãôÂßãÁµÇÊ¥ªË∫ç
        self.health_url = f"https://{os.getenv('RENDER_EXTERNAL_HOSTNAME', 'localhost:8080')}/health"
        self.last_keep_alive = None
        
        # ÂàùÂßãÂåñ‰∫§‰∫íÂºèTelegramÂ§ÑÁêÜÂô® - Ê∑ªÂä†Ë©≥Á¥∞Êó•Ë™å
        self.interactive_handler = None
        self.webhook_handler = None
        self.logger.info("=" * 60)
        self.logger.info("üîß ÈñãÂßãÂàùÂßãÂåñWebhookÂºèTelegramËôïÁêÜÂô®...")
        self.logger.info("=" * 60)
        
        # Ê™¢Êü•ÊòØÂê¶ÂïüÁî®WebhookÂäüËÉΩ
        if not WEBHOOK_AVAILABLE:
            self.logger.error("‚ùå WebhookÊ®°ÁµÑ‰∏çÂèØÁî® - Êú™ÊâæÂà∞ webhook_telegram_handler")
            self.logger.error(f"   WEBHOOK_AVAILABLE = {WEBHOOK_AVAILABLE}")
            self.logger.error(f"   WebhookTelegramHandler = {WebhookTelegramHandler}")
            # ÂòóË©¶‰ΩøÁî®Èï∑Ëº™Ë©¢‰ΩúÁÇ∫ÂÇôÁî®
            if INTERACTIVE_AVAILABLE:
                self.logger.info("üîÑ ÂòóË©¶‰ΩøÁî®Èï∑Ëº™Ë©¢Ê®°Âºè‰ΩúÁÇ∫ÂÇôÁî®...")
                self._init_polling_handler()
            return
            
        self.logger.info(f"‚úÖ WebhookÊ®°ÁµÑÂèØÁî®: WEBHOOK_AVAILABLE = {WEBHOOK_AVAILABLE}")
            
        if not self.config['notifications']['telegram_enabled']:
            self.logger.warning("‚ö†Ô∏è  TelegramÈÄöÁü•Êú™ÂïüÁî®ÔºåË∑≥ÈÅéWebhookÂäüËÉΩ")
            self.logger.warning(f"   telegram_enabled = {self.config['notifications']['telegram_enabled']}")
            return
            
        self.logger.info(f"‚úÖ TelegramÈÄöÁü•Â∑≤ÂïüÁî®: {self.config['notifications']['telegram_enabled']}")
        
        # Ê™¢Êü•Áí∞Â¢ÉËÆäÊï∏
        bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
        chat_id = os.getenv('TELEGRAM_CHAT_ID')
        
        self.logger.info(f"üì± Áí∞Â¢ÉËÆäÊï∏Ê™¢Êü•:")
        self.logger.info(f"   Bot TokenÊ™¢Êü•: {'‚úÖ Â∑≤Ë®≠ÁΩÆ' if bot_token else '‚ùå Êú™Ë®≠ÁΩÆ'}")
        if bot_token:
            self.logger.info(f"   Bot Token (Ââç10Â≠óÂÖÉ): {bot_token[:10]}...")
        self.logger.info(f"   Chat IDÊ™¢Êü•: {'‚úÖ Â∑≤Ë®≠ÁΩÆ' if chat_id else '‚ùå Êú™Ë®≠ÁΩÆ'}")
        if chat_id:
            self.logger.info(f"   Chat ID: {chat_id}")
        
        if not bot_token:
            self.logger.error("‚ùå TELEGRAM_BOT_TOKEN Áí∞Â¢ÉËÆäÊï∏Êú™Ë®≠ÁΩÆÔºåÁÑ°Ê≥ïÂïüÂãïWebhookÂäüËÉΩ")
            self.logger.error("   Ë´ãÂú®Render.comÊéßÂà∂Âè∞Á¢∫Ë™çÁí∞Â¢ÉËÆäÊï∏Ë®≠ÁΩÆ")
            return
            
        if not chat_id:
            self.logger.error("‚ùå TELEGRAM_CHAT_ID Áí∞Â¢ÉËÆäÊï∏Êú™Ë®≠ÁΩÆÔºåÁÑ°Ê≥ïÂïüÂãïWebhookÂäüËÉΩ")
            self.logger.error("   Ë´ãÂú®Render.comÊéßÂà∂Âè∞Á¢∫Ë™çÁí∞Â¢ÉËÆäÊï∏Ë®≠ÁΩÆ")
            return
        
        try:
            self.logger.info("üöÄ Ê≠£Âú®ÂâµÂª∫WebhookËôïÁêÜÂô®ÂØ¶‰æã...")
            self.logger.info(f"   ‰ΩøÁî®Bot Token: {bot_token[:10]}...")
            self.logger.info(f"   ‰ΩøÁî®Chat ID: {chat_id}")
            self.logger.info(f"   ÂÇ≥ÂÖ•CloudMonitorÂØ¶‰æã: {type(self).__name__}")
            
            self.webhook_handler = WebhookTelegramHandler(bot_token, chat_id, self)
            self.logger.info("‚úÖ WebhookËôïÁêÜÂô®ÂØ¶‰æãÂâµÂª∫ÊàêÂäü")
            self.logger.info(f"   ËôïÁêÜÂô®È°ûÂûã: {type(self.webhook_handler).__name__}")
            self.logger.info(f"   ËôïÁêÜÂô®Chat ID: {self.webhook_handler.chat_id}")
            
        except Exception as e:
            self.logger.error("=" * 60)
            self.logger.error("‚ùå WebhookËôïÁêÜÂô®ÂàùÂßãÂåñÂ§±Êïó")
            self.logger.error("=" * 60)
            self.logger.error(f"ÈåØË™§È°ûÂûã: {type(e).__name__}")
            self.logger.error(f"ÈåØË™§Ë®äÊÅØ: {e}")
            import traceback
            self.logger.error(f"Ë©≥Á¥∞ÈåØË™§ËøΩËπ§:")
            for line in traceback.format_exc().split('\n'):
                if line.strip():
                    self.logger.error(f"   {line}")
            self.logger.error("=" * 60)
            self.webhook_handler = None
        
        self.logger.info("=" * 60)
        self.logger.info(f"üèÅ WebhookËôïÁêÜÂô®ÂàùÂßãÂåñÂÆåÊàê")
        self.logger.info(f"   ÊúÄÁµÇÁãÄÊÖã: {'‚úÖ ÊàêÂäü' if self.webhook_handler else '‚ùå Â§±Êïó'}")
        self.logger.info("=" * 60)
    
    def _init_polling_handler(self):
        """ÂàùÂßãÂåñÈï∑Ëº™Ë©¢ËôïÁêÜÂô®‰ΩúÁÇ∫ÂÇôÁî®"""
        try:
            bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
            chat_id = os.getenv('TELEGRAM_CHAT_ID')
            
            if bot_token and chat_id:
                self.interactive_handler = InteractiveTelegramHandler(bot_token, chat_id, self)
                self.logger.info("‚úÖ Èï∑Ëº™Ë©¢ËôïÁêÜÂô®ÂàùÂßãÂåñÊàêÂäüÔºàÂÇôÁî®Ê®°ÂºèÔºâ")
            else:
                self.logger.error("‚ùå Èï∑Ëº™Ë©¢ËôïÁêÜÂô®ÂàùÂßãÂåñÂ§±ÊïóÔºöÁí∞Â¢ÉËÆäÊï∏‰∏çË∂≥")
        except Exception as e:
            self.logger.error(f"‚ùå Èï∑Ëº™Ë©¢ËôïÁêÜÂô®ÂàùÂßãÂåñÂ§±Êïó: {e}")
        
    def apply_env_overrides(self):
        """‰ΩøÁî®Áí∞Â¢ÉËÆäÈáèË¶ÜËìãÈÖçÁΩÆ"""
        # TelegramË®≠ÁΩÆ
        if os.getenv('TELEGRAM_BOT_TOKEN'):
            # Á¢∫‰øùtelegram_notifierÊúâÊ≠£Á¢∫ÁöÑtoken
            os.environ.setdefault('TELEGRAM_BOT_TOKEN', os.getenv('TELEGRAM_BOT_TOKEN'))
        
        if os.getenv('TELEGRAM_CHAT_ID'):
            os.environ.setdefault('TELEGRAM_CHAT_ID', os.getenv('TELEGRAM_CHAT_ID'))
        
        # Áõ£ÊéßË®≠ÁΩÆ
        if os.getenv('MONITOR_INTERVAL'):
            self.config['monitoring']['check_interval'] = int(os.getenv('MONITOR_INTERVAL'))
        
        if os.getenv('PRIMARY_PERIOD'):
            self.config['monitoring']['primary_period'] = int(os.getenv('PRIMARY_PERIOD'))
        
        if os.getenv('CHECK_SYMBOLS'):
            symbols = os.getenv('CHECK_SYMBOLS').split(',')
            self.config['monitoring']['symbols'] = [s.strip() for s in symbols]
        
        # ÈÄöÁü•Ë®≠ÁΩÆ
        if os.getenv('COOLDOWN_PERIOD'):
            self.config['advanced']['cooldown_period'] = int(os.getenv('COOLDOWN_PERIOD'))
        
        if os.getenv('MAX_ALERTS_PER_HOUR'):
            self.config['advanced']['max_alerts_per_hour'] = int(os.getenv('MAX_ALERTS_PER_HOUR'))
        
        # ÊúçÂãôË®≠ÁΩÆ
        if os.getenv('PORT'):
            self.config['cloud']['health_check_port'] = int(os.getenv('PORT'))
        
        if os.getenv('LOG_LEVEL'):
            self.config['logging'] = {'level': os.getenv('LOG_LEVEL').upper()}
        
        if os.getenv('TIMEZONE'):
            self.config['cloud']['timezone'] = os.getenv('TIMEZONE')
    
    def load_config(self) -> Dict[str, Any]:
        """ËºâÂÖ•ÈÖçÁΩÆÊñá‰ª∂"""
        default_config = {
            "monitoring": {
                "symbols": ["btctwd"],
                "periods": [1, 5, 15, 30, 60],
                "check_interval": 60,
                "primary_period": 60
            },
            "alerts": {
                "macd_crossover": True,
                "signal_strength_threshold": 70,
                "price_change_threshold": 2.0,
                "volume_spike_threshold": 1.5,
                "rsi_overbought": 80,
                "rsi_oversold": 20
            },
            "notifications": {
                "telegram_enabled": True,
                "email_enabled": False,
                "slack_enabled": False,
                "discord_enabled": False
            },
            "cloud": {
                "platform": "local",  # local, heroku, aws, gcp, azure
                "health_check_port": 8080,
                "timezone": "Asia/Taipei"
            },
            "advanced": {
                "cooldown_period": 300,
                "max_alerts_per_hour": 10,
                "enable_backtesting": False,
                "data_retention_days": 30
            }
        }
        
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    loaded_config = json.load(f)
                # Âêà‰ΩµÈÖçÁΩÆ
                default_config.update(loaded_config)
            else:
                # ÂâµÂª∫ÈªòË™çÈÖçÁΩÆÊñá‰ª∂
                self.save_config(default_config)
                
        except Exception as e:
            print(f"‚ö†Ô∏è  ÈÖçÁΩÆÊñá‰ª∂ËºâÂÖ•ÈåØË™§Ôºå‰ΩøÁî®ÈªòË™çÈÖçÁΩÆ: {e}")
            
        return default_config
    
    def save_config(self, config: Dict[str, Any] = None):
        """‰øùÂ≠òÈÖçÁΩÆÊñá‰ª∂"""
        if config is None:
            config = self.config
            
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=4, ensure_ascii=False)
        except Exception as e:
            self.logger.error(f"‰øùÂ≠òÈÖçÁΩÆÊñá‰ª∂Â§±Êïó: {e}")
    
    def setup_logging(self):
        """Ë®≠ÁΩÆÊó•Ë™å"""
        # ÂâµÂª∫logsÁõÆÈåÑ
        if not os.path.exists('logs'):
            os.makedirs('logs')
        
        # Ë®≠ÁΩÆÊó•Ë™åÊ†ºÂºèÔºàÁßªÈô§emojiÈÅøÂÖçÁ∑®Á¢ºÂïèÈ°åÔºâ
        log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        
        logging.basicConfig(
            level=logging.INFO,
            format=log_format,
            handlers=[
                logging.FileHandler('logs/cloud_monitor.log', encoding='utf-8'),
                logging.StreamHandler()  # ÁßªÈô§Á∑®Á¢ºË®≠ÁΩÆÔºåËÆìÁ≥ªÁµ±Ëá™ÂãïËôïÁêÜ
            ]
        )
        
        self.logger = logging.getLogger('CloudMonitor')
        self.logger.info("Èõ≤Á´ØÁõ£ÊéßÁ≥ªÁµ±Êó•Ë™åÂ∑≤ÂïüÂãï")
        
    async def check_market_conditions(self, symbol: str) -> Optional[Dict[str, Any]]:
        """Ê™¢Êü•Â∏ÇÂ†¥Ê¢ù‰ª∂"""
        try:
            self.logger.info(f"ÈñãÂßãÊ™¢Êü• {symbol} Â∏ÇÂ†¥Ê¢ù‰ª∂")
            
            # Áç≤ÂèñÂÉπÊ†ºÊï∏Êìö
            self.logger.info("Ê≠£Âú®Áç≤ÂèñÂÉπÊ†ºÊï∏Êìö...")
            ticker = self.max_api.get_ticker(symbol)
            if not ticker:
                self.logger.error(f"ÁÑ°Ê≥ïÁç≤Âèñ {symbol} ÂÉπÊ†ºÊï∏Êìö")
                return None
            
            self.logger.info(f"ÂÉπÊ†ºÊï∏ÊìöÁç≤ÂèñÊàêÂäü: {ticker.get('price', 'N/A')}")
            
            # Áç≤Âèñ‰∏ªË¶ÅÈÄ±ÊúüÁöÑKÁ∑öÊï∏Êìö
            primary_period = self.config['monitoring']['primary_period']
            self.logger.info(f"Ê≠£Âú®Áç≤Âèñ {primary_period} ÂàÜÈêòKÁ∑öÊï∏Êìö...")
            kline_data = self.max_api.get_klines(symbol, period=primary_period, limit=200)
            
            if kline_data is None or kline_data.empty:
                self.logger.error(f"ÁÑ°Ê≥ïÁç≤Âèñ {symbol} KÁ∑öÊï∏Êìö")
                return None
            
            self.logger.info(f"KÁ∑öÊï∏ÊìöÁç≤ÂèñÊàêÂäüÔºåÂÖ± {len(kline_data)} Ê¢ùË®òÈåÑ")
            
            # Ë®àÁÆóÊäÄË°ìÊåáÊ®ô
            self.logger.info("Ê≠£Âú®Ë®àÁÆóÊäÄË°ìÊåáÊ®ô...")
            df_with_macd = self.macd_analyzer.calculate_macd(kline_data)
            if df_with_macd is None or df_with_macd.empty:
                self.logger.error(f"MACDË®àÁÆóÂ§±Êïó")
                return None
            
            if len(df_with_macd) < 2:
                self.logger.error(f"ÊäÄË°ìÊåáÊ®ôÊï∏Êìö‰∏çË∂≥ÔºåÂè™Êúâ {len(df_with_macd)} Ê¢ùË®òÈåÑ")
                return None
            
            self.logger.info("ÊäÄË°ìÊåáÊ®ôË®àÁÆóÊàêÂäü")
            
            latest = df_with_macd.iloc[-1]
            previous = df_with_macd.iloc[-2]
            
            # ÂÆâÂÖ®Áç≤ÂèñÊäÄË°ìÊåáÊ®ôÊï∏ÊìöÔºå‰ΩøÁî®ÈªòË™çÂÄºËôïÁêÜÁº∫Â§±È†Ö
            def safe_get(series, key, default=0.0):
                try:
                    value = series.get(key, default)
                    return float(value) if pd.notna(value) else default
                except:
                    return default
            
            # ÊßãÂª∫Â∏ÇÂ†¥Ê¢ù‰ª∂Êï∏Êìö
            market_data = {
                'symbol': symbol,
                'timestamp': datetime.now(),
                'price': {
                    'current': float(ticker['price']),
                    'high_24h': float(ticker['high']),
                    'low_24h': float(ticker['low']),
                    'volume_24h': float(ticker['volume'])
                },
                'technical': {
                    'macd': safe_get(latest, 'macd'),
                    'macd_signal': safe_get(latest, 'macd_signal'),
                    'macd_histogram': safe_get(latest, 'macd_histogram'),
                    'rsi': safe_get(latest, 'rsi', 50.0),  # RSI ÈªòË™çÂÄº 50
                    'ema_12': safe_get(latest, 'ema_12'),
                    'ema_26': safe_get(latest, 'ema_26')
                },
                'previous': {
                    'macd': safe_get(previous, 'macd'),
                    'macd_signal': safe_get(previous, 'macd_signal'),
                    'macd_histogram': safe_get(previous, 'macd_histogram')
                },
                'df': df_with_macd  # Ê∑ªÂä†ÂÆåÊï¥ÁöÑKÁ∑öÊï∏Êìö‰æõÈ´òÁ¥öÂàÜÊûê‰ΩøÁî®
            }
            
            self.logger.info(f"Â∏ÇÂ†¥Ê¢ù‰ª∂Ê™¢Êü•ÂÆåÊàê: MACD={market_data['technical']['macd']:.2f}, RSI={market_data['technical']['rsi']:.1f}")
            return market_data
            
        except Exception as e:
            self.logger.error(f"Ê™¢Êü•Â∏ÇÂ†¥Ê¢ù‰ª∂ÊôÇÂá∫ÈåØ: {e}")
            import traceback
            self.logger.error(f"Ë©≥Á¥∞ÈåØË™§: {traceback.format_exc()}")
            self.stats['errors_count'] += 1
            return None
    
    def analyze_alerts(self, market_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """ÂàÜÊûê‰∏¶ÁîüÊàêË≠¶Â†±"""
        alerts = []
        
        try:
            current = market_data['technical']
            previous = market_data['previous']
            price = market_data['price']
            config = self.config['alerts']
            
            # MACDÈáëÂèâÊ≠ªÂèâ
            if config['macd_crossover']:
                macd_current = current['macd']
                signal_current = current['macd_signal']
                macd_prev = previous['macd']
                signal_prev = previous['macd_signal']
                
                # ÈáëÂèâ
                if macd_prev <= signal_prev and macd_current > signal_current:
                    alerts.append({
                        'type': 'MACD_GOLDEN_CROSS',
                        'priority': 'HIGH',
                        'message': f'MACDÈáëÂèâ‰ø°ËôüÔºÅMACD({macd_current:.4f}) > Signal({signal_current:.4f})',
                        'action': 'BUY',
                        'strength': 85
                    })
                
                # Ê≠ªÂèâ
                elif macd_prev >= signal_prev and macd_current < signal_current:
                    alerts.append({
                        'type': 'MACD_DEATH_CROSS',
                        'priority': 'HIGH',
                        'message': f'MACDÊ≠ªÂèâ‰ø°ËôüÔºÅMACD({macd_current:.4f}) < Signal({signal_current:.4f})',
                        'action': 'SELL',
                        'strength': 85
                    })
            
            # RSIË∂ÖË≤∑Ë∂ÖË≥£
            rsi = current['rsi']
            if rsi >= config['rsi_overbought']:
                alerts.append({
                    'type': 'RSI_OVERBOUGHT',
                    'priority': 'MEDIUM',
                    'message': f'RSIË∂ÖË≤∑Ë≠¶ÂëäÔºÅÁï∂ÂâçRSI: {rsi:.1f}',
                    'action': 'SELL',
                    'strength': 60
                })
            elif rsi <= config['rsi_oversold']:
                alerts.append({
                    'type': 'RSI_OVERSOLD',
                    'priority': 'MEDIUM',
                    'message': f'RSIË∂ÖË≥£Ë≠¶ÂëäÔºÅÁï∂ÂâçRSI: {rsi:.1f}',
                    'action': 'BUY',
                    'strength': 60
                })
            
            # ÂÉπÊ†ºËÆäÂåñË≠¶Â†±
            # ÈÄôË£°ÈúÄË¶ÅÊ≠∑Âè≤ÂÉπÊ†ºÊï∏Êìö‰æÜË®àÁÆóËÆäÂåñÁôæÂàÜÊØî
            # Êö´ÊôÇË∑≥ÈÅéÔºåÂèØ‰ª•Âú®ÂæåÁ∫åÁâàÊú¨‰∏≠Âä†ÂÖ•
            
            return alerts
            
        except Exception as e:
            self.logger.error(f"ÂàÜÊûêË≠¶Â†±ÊôÇÂá∫ÈåØ: {e}")
            return []
    
    def should_send_alert(self, alert: Dict[str, Any]) -> bool:
        """Ê™¢Êü•ÊòØÂê¶ÊáâË©≤ÁôºÈÄÅË≠¶Â†±"""
        alert_type = alert['type']
        now = datetime.now()
        
        # Ê™¢Êü•ÂÜ∑ÂçªÊúü
        cooldown = self.config['advanced']['cooldown_period']
        if alert_type in self.last_alerts:
            time_diff = (now - self.last_alerts[alert_type]).total_seconds()
            if time_diff < cooldown:
                return False
        
        # Ê™¢Êü•ÊØèÂ∞èÊôÇË≠¶Â†±ÈôêÂà∂
        max_per_hour = self.config['advanced']['max_alerts_per_hour']
        hour_ago = now - timedelta(hours=1)
        recent_alerts = sum(1 for time in self.last_alerts.values() if time > hour_ago)
        
        if recent_alerts >= max_per_hour:
            return False
        
        return True
    
    async def send_notifications(self, alerts: List[Dict[str, Any]], market_data: Dict[str, Any]):
        """ÁôºÈÄÅÈÄöÁü•"""
        notifications = self.config['notifications']
        
        for alert in alerts:
            if not self.should_send_alert(alert):
                continue
            
            try:
                # TelegramÈÄöÁü•
                if notifications['telegram_enabled']:
                    signal_data = {
                        'signal': alert['action'],
                        'strength': alert['strength'],
                        'reason': alert['message'],
                        'macd_current': market_data['technical']['macd'],
                        'macd_signal_current': market_data['technical']['macd_signal'],
                        'histogram_current': market_data['technical']['macd_histogram'],
                        'rsi_current': market_data['technical']['rsi']
                    }
                    
                    price_data = {
                        'price': market_data['price']['current'],
                        'high': market_data['price']['high_24h'],
                        'low': market_data['price']['low_24h'],
                        'volume': market_data['price']['volume_24h']
                    }
                    
                    success = await self.telegram_notifier.send_signal_notification(signal_data, price_data)
                    if success:
                        self.last_alerts[alert['type']] = datetime.now()
                        self.stats['alerts_sent'] += 1
                        self.logger.info(f"Â∑≤ÁôºÈÄÅTelegramË≠¶Â†±: {alert['type']}")
                
                # ÂÖ∂‰ªñÈÄöÁü•ÊñπÂºèÂèØ‰ª•Âú®ÈÄôË£°Ê∑ªÂä†
                # Email, Slack, DiscordÁ≠â
                
            except Exception as e:
                self.logger.error(f"ÁôºÈÄÅÈÄöÁü•Â§±Êïó: {e}")
    
    async def monitoring_cycle(self):
        """Áõ£ÊéßÂæ™Áí∞"""
        self.logger.info("ÈñãÂßãÁõ£ÊéßÂæ™Áí∞")
        
        for symbol in self.config['monitoring']['symbols']:
            try:
                # Ê™¢Êü•Â∏ÇÂ†¥Ê¢ù‰ª∂
                market_data = await self.check_market_conditions(symbol)
                if not market_data:
                    continue
                
                # ÂàÜÊûêË≠¶Â†±
                alerts = self.analyze_alerts(market_data)
                
                # ÁôºÈÄÅÈÄöÁü•
                if alerts:
                    await self.send_notifications(alerts, market_data)
                
                # Êõ¥Êñ∞Áµ±Ë®à
                self.stats['checks_performed'] += 1
                self.monitoring_data[symbol] = market_data
                
                self.logger.info(f"{symbol} Áõ£ÊéßÂÆåÊàê - ÁôºÁèæ {len(alerts)} ÂÄãË≠¶Â†±")
                
            except Exception as e:
                self.logger.error(f"Áõ£Êéß {symbol} ÊôÇÂá∫ÈåØ: {e}")
                self.stats['errors_count'] += 1
    
    async def run_forever(self):
        """ÊåÅÁ∫åÈÅãË°åÁõ£Êéß"""
        self.is_running = True
        self.stats['start_time'] = datetime.now(TAIWAN_TZ)
        
        self.logger.info("Èõ≤Á´ØÁõ£ÊéßÁ≥ªÁµ±ÂïüÂãï")
        
        # ÂïüÂãïWebhookÂºèTelegramËôïÁêÜÂô®
        self.logger.info("=" * 60)
        self.logger.info("üöÄ Ê∫ñÂÇôÂïüÂãïWebhookÂºèTelegramËôïÁêÜÂô®...")
        self.logger.info("=" * 60)
        
        if self.webhook_handler:
            self.logger.info("‚úÖ WebhookËôïÁêÜÂô®ÂØ¶‰æãÂ≠òÂú®ÔºåÈñãÂßãÂïüÂãï...")
            self.logger.info(f"   ËôïÁêÜÂô®È°ûÂûã: {type(self.webhook_handler).__name__}")
            self.logger.info(f"   ËôïÁêÜÂô®Chat ID: {self.webhook_handler.chat_id}")
            try:
                self.logger.info("üîÑ Ê≠£Âú®Ë®≠ÁΩÆWebhook...")
                await self.webhook_handler.setup_webhook()
                
                self.logger.info("üîÑ Ê≠£Âú®ÂïüÂãïWebhookÊúçÂãôÂô®...")
                await self.webhook_handler.start_webhook_server()
                
                self.logger.info("‚úÖ WebhookÂºèTelegramË®äÊÅØËôïÁêÜÂ∑≤ÂïüÂãï")
            except Exception as e:
                self.logger.error("=" * 50)
                self.logger.error("‚ùå ÂïüÂãïWebhookËôïÁêÜÂô®Â§±Êïó")
                self.logger.error("=" * 50)
                self.logger.error(f"ÈåØË™§È°ûÂûã: {type(e).__name__}")
                self.logger.error(f"ÈåØË™§Ë®äÊÅØ: {e}")
                import traceback
                self.logger.error("Ë©≥Á¥∞ÈåØË™§ËøΩËπ§:")
                for line in traceback.format_exc().split('\n'):
                    if line.strip():
                        self.logger.error(f"   {line}")
                self.logger.error("=" * 50)
        elif self.interactive_handler:
            self.logger.info("üîÑ ‰ΩøÁî®Èï∑Ëº™Ë©¢ËôïÁêÜÂô®‰ΩúÁÇ∫ÂÇôÁî®...")
            try:
                await self.interactive_handler.start_polling()
                self.logger.info("‚úÖ Èï∑Ëº™Ë©¢ËôïÁêÜÂô®Â∑≤ÂïüÂãïÔºàÂÇôÁî®Ê®°ÂºèÔºâ")
            except Exception as e:
                self.logger.error(f"‚ùå Èï∑Ëº™Ë©¢ËôïÁêÜÂô®ÂïüÂãïÂ§±Êïó: {e}")
        else:
            self.logger.error("‚ùå Ê≤íÊúâÂèØÁî®ÁöÑTelegramËôïÁêÜÂô®")
            self.logger.error("‚ö†Ô∏è  ÊâÄÊúâTelegramËôïÁêÜÂô®ÈÉΩÊú™ÂàùÂßãÂåñ - Ê™¢Êü•Áí∞Â¢ÉËÆäÊï∏ÂíåÈÖçÁΩÆ")
            # ÂÜçÊ¨°Ê™¢Êü•ÂéüÂõ†
            self.logger.error("üîç Ë®∫Êñ∑ÂéüÂõ†:")
            if not WEBHOOK_AVAILABLE and not INTERACTIVE_AVAILABLE:
                self.logger.error("   ÂéüÂõ†: ÊâÄÊúâËôïÁêÜÂô®Ê®°ÁµÑÈÉΩ‰∏çÂèØÁî®")
            elif not self.config['notifications']['telegram_enabled']:
                self.logger.error("   ÂéüÂõ†: TelegramÈÄöÁü•Êú™ÂïüÁî®")
            elif not os.getenv('TELEGRAM_BOT_TOKEN'):
                self.logger.error("   ÂéüÂõ†: TELEGRAM_BOT_TOKEN Áí∞Â¢ÉËÆäÊï∏Êú™Ë®≠ÁΩÆ")
            elif not os.getenv('TELEGRAM_CHAT_ID'):
                self.logger.error("   ÂéüÂõ†: TELEGRAM_CHAT_ID Áí∞Â¢ÉËÆäÊï∏Êú™Ë®≠ÁΩÆ")
            else:
                self.logger.error("   ÂéüÂõ†: Êú™Áü•ÂàùÂßãÂåñÈåØË™§")
        
        self.logger.info("=" * 60)
        self.logger.info(f"üèÅ TelegramËôïÁêÜÂô®ÂïüÂãïÊµÅÁ®ãÂÆåÊàê")
        self.logger.info(f"   WebhookÁãÄÊÖã: {'‚úÖ ÈÅãË°å‰∏≠' if self.webhook_handler else '‚ùå Êú™ÈÅãË°å'}")
        self.logger.info(f"   Èï∑Ëº™Ë©¢ÁãÄÊÖã: {'‚úÖ ÈÅãË°å‰∏≠' if self.interactive_handler else '‚ùå Êú™ÈÅãË°å'}")
        self.logger.info("=" * 60)
        
        # ÁôºÈÄÅÂïüÂãïÈÄöÁü•
        if self.config['notifications']['telegram_enabled']:
            # Ê™¢Êü•AIÂàÜÊûêÂäüËÉΩÁãÄÊÖã - ÊîØÊåÅWebhookÂíåÈï∑Ëº™Ë©¢ÂÖ©Á®ÆÊ®°Âºè
            ai_enabled = bool(self.webhook_handler or self.interactive_handler)
            ai_mode = ""
            if self.webhook_handler:
                ai_mode = " (WebhookÊ®°Âºè)"
            elif self.interactive_handler:
                ai_mode = " (Èï∑Ëº™Ë©¢Ê®°Âºè)"
            
            start_message = f"""
ü§ñ <b>Èõ≤Á´ØÁõ£ÊéßÁ≥ªÁµ±ÂïüÂãï</b>

üìä <b>Áõ£ÊéßË®≠ÂÆö:</b>
‚Ä¢ ‰∫§ÊòìÂ∞ç: {', '.join(self.config['monitoring']['symbols'])}
‚Ä¢ ÈÄ±Êúü: {self.config['monitoring']['primary_period']}ÂàÜÈêò
‚Ä¢ Ê™¢Êü•ÈñìÈöî: {self.config['monitoring']['check_interval']}Áßí

üí¨ <b>‰∫§‰∫íÂºèÂäüËÉΩ:</b>
‚Ä¢ AIÂàÜÊûê: {'‚úÖ Â∑≤ÂïüÁî®' if ai_enabled else '‚ùå Êú™ÂïüÁî®'}{ai_mode}

üíì <b>‰øùÊ¥ªÂäüËÉΩ:</b>
‚Ä¢ Ëá™Âãï‰øùÊ¥ª: {'‚úÖ Â∑≤ÂïüÁî®' if self.keep_alive_enabled else '‚ùå Â∑≤Á¶ÅÁî®'}
{f'‚Ä¢ PingÈñìÈöî: {self.keep_alive_interval//60}ÂàÜÈêò ({self.keep_alive_interval}Áßí)' if self.keep_alive_enabled else ''}

‚è∞ <b>ÂïüÂãïÊôÇÈñì:</b> {datetime.now(TAIWAN_TZ).strftime('%Y-%m-%d %H:%M:%S')} (Âè∞ÁÅ£ÊôÇÈñì)

üîî Á≥ªÁµ±Â∞áÈñãÂßãÁõ£ÊéßÂ∏ÇÂ†¥‰∏¶ÁôºÈÄÅË≠¶Â†±ÈÄöÁü•

üí° <b>‰ΩøÁî®ÊñπÊ≥ï:</b>
ÁôºÈÄÅ "Ë≤∑ÈÄ≤?" Êàñ "Ë≥£Âá∫?" ÂèØÁç≤ÂæóAIÂàÜÊûêÂª∫Ë≠∞
            """
            
            try:
                await self.telegram_notifier.bot.send_message(
                    chat_id=self.telegram_notifier.chat_id,
                    text=start_message.strip(),
                    parse_mode='HTML'
                )
                self.logger.info("‚úÖ ÂïüÂãïÈÄöÁü•Â∑≤ÁôºÈÄÅ")
            except Exception as e:
                self.logger.error(f"‚ùå ÁôºÈÄÅÂïüÂãïÈÄöÁü•Â§±Êïó: {e}")
        
        # ‰∏ªÁõ£ÊéßÂæ™Áí∞
        interval = self.config['monitoring']['check_interval']
        
        # ÂâµÂª∫‰øùÊ¥ª‰ªªÂãô
        keep_alive_task = None
        if self.keep_alive_enabled:
            keep_alive_task = asyncio.create_task(self.keep_alive_task())
            self.logger.info("üíì ‰øùÊ¥ª‰ªªÂãôÂ∑≤ÂïüÂãï")
        
        try:
            while self.is_running:
                start_time = time.time()
                
                await self.monitoring_cycle()
                
                # Ë®àÁÆóÁ≠âÂæÖÊôÇÈñì
                elapsed = time.time() - start_time
                wait_time = max(0, interval - elapsed)
                
                if wait_time > 0:
                    await asyncio.sleep(wait_time)
                
        except KeyboardInterrupt:
            self.logger.info("Êî∂Âà∞ÂÅúÊ≠¢‰ø°Ëôü")
        except Exception as e:
            self.logger.error(f"Áõ£ÊéßÂæ™Áí∞Âá∫ÈåØ: {e}")
        finally:
            # ÂèñÊ∂à‰øùÊ¥ª‰ªªÂãô
            if keep_alive_task:
                keep_alive_task.cancel()
                try:
                    await keep_alive_task
                except asyncio.CancelledError:
                    pass
                self.logger.info("üíì ‰øùÊ¥ª‰ªªÂãôÂ∑≤ÂÅúÊ≠¢")
            
            await self.stop()
    
    async def stop(self):
        """ÂÅúÊ≠¢Áõ£Êéß"""
        self.is_running = False
        
        # ÂÅúÊ≠¢‰∫§‰∫íÂºèTelegramÂ§ÑÁêÜÂô®
        if self.interactive_handler:
            try:
                await self.interactive_handler.stop_polling()
                self.logger.info("‰∫§‰∫íÂºèTelegramË®äÊÅØËôïÁêÜÂ∑≤ÂÅúÊ≠¢")
            except Exception as e:
                self.logger.error(f"ÂÅúÊ≠¢‰∫§‰∫íÂºèËôïÁêÜÂô®Â§±Êïó: {e}")
        
        # ÁôºÈÄÅÂÅúÊ≠¢ÈÄöÁü•
        if self.config['notifications']['telegram_enabled']:
            runtime = datetime.now(TAIWAN_TZ) - self.stats['start_time'] if self.stats['start_time'] else timedelta(0)
            
            stop_message = f"""
üõë <b>Èõ≤Á´ØÁõ£ÊéßÁ≥ªÁµ±ÂÅúÊ≠¢</b>

üìä <b>ÈÅãË°åÁµ±Ë®à:</b>
‚Ä¢ ÈÅãË°åÊôÇÈñì: {str(runtime).split('.')[0]}
‚Ä¢ Ê™¢Êü•Ê¨°Êï∏: {self.stats['checks_performed']}
‚Ä¢ Ë≠¶Â†±ÁôºÈÄÅ: {self.stats['alerts_sent']}
‚Ä¢ ÈåØË™§Ê¨°Êï∏: {self.stats['errors_count']}

‚è∞ <b>ÂÅúÊ≠¢ÊôÇÈñì:</b> {datetime.now(TAIWAN_TZ).strftime('%Y-%m-%d %H:%M:%S')} (Âè∞ÁÅ£ÊôÇÈñì)
            """
            
            try:
                await self.telegram_notifier.bot.send_message(
                    chat_id=self.telegram_notifier.chat_id,
                    text=stop_message.strip(),
                    parse_mode='HTML'
                )
            except Exception as e:
                self.logger.error(f"ÁôºÈÄÅÂÅúÊ≠¢ÈÄöÁü•Â§±Êïó: {e}")
        
        self.logger.info("Èõ≤Á´ØÁõ£ÊéßÁ≥ªÁµ±Â∑≤ÂÅúÊ≠¢")
    
    async def keep_alive_ping(self):
        """ÁôºÈÄÅ‰øùÊ¥ªpingË´ãÊ±Ç"""
        if not self.keep_alive_enabled:
            return
            
        try:
            # Ê∑ªÂä†Â§öÂÄãÁ´ØÈªûpingÔºåÁ¢∫‰øùÊúçÂãôÊ¥ªË∫ç
            endpoints = [
                f"{self.health_url}",
                f"{self.health_url.replace('/health', '/status')}" if '/health' in self.health_url else None
            ]
            
            success_count = 0
            for endpoint in endpoints:
                if endpoint is None:
                    continue
                    
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(endpoint, timeout=10) as response:
                            if response.status == 200:
                                success_count += 1
                                self.last_keep_alive = datetime.now(TAIWAN_TZ)
                                self.logger.info(f"‰øùÊ¥ªpingÊàêÂäü: {endpoint} (ÁãÄÊÖã: {response.status})")
                            else:
                                self.logger.warning(f"‰øùÊ¥ªpingÂõûÊáâÁï∞Â∏∏: {endpoint} (ÁãÄÊÖã: {response.status})")
                except Exception as e:
                    self.logger.warning(f"ÂñÆÂÄãÁ´ØÈªûpingÂ§±Êïó: {endpoint} - {e}")
            
            if success_count == 0:
                self.logger.error("ÊâÄÊúâ‰øùÊ¥ªpingÈÉΩÂ§±Êïó‰∫Ü")
            else:
                self.logger.info(f"‰øùÊ¥ªÂÆåÊàê - {success_count}/{len([e for e in endpoints if e])} ÂÄãÁ´ØÈªûÊàêÂäü")
                
        except Exception as e:
            self.logger.warning(f"‰øùÊ¥ªpingÂ§±Êïó: {e}")
    
    async def keep_alive_task(self):
        """‰øùÊ¥ª‰ªªÂãôÔºàËÉåÊôØÈÅãË°åÔºâ"""
        if not self.keep_alive_enabled:
            self.logger.info("‰øùÊ¥ªÂäüËÉΩÂ∑≤Á¶ÅÁî®")
            return
            
        self.logger.info(f"‰øùÊ¥ªÂäüËÉΩÂ∑≤ÂïüÂãï - ÈñìÈöî: {self.keep_alive_interval}Áßí ({self.keep_alive_interval//60}ÂàÜÈêò)")
        self.logger.info(f"   ÁõÆÊ®ôURL: {self.health_url}")
        
        # Á´ãÂç≥Âü∑Ë°åÁ¨¨‰∏ÄÊ¨°ping
        self.logger.info("Âü∑Ë°åÂàùÂßã‰øùÊ¥ªping...")
        await self.keep_alive_ping()
        
        ping_count = 1
        while self.is_running:
            try:
                await asyncio.sleep(self.keep_alive_interval)
                if self.is_running:  # ÂÜçÊ¨°Ê™¢Êü•ÔºåÈÅøÂÖçÂÅúÊ≠¢ÊôÇÂü∑Ë°å
                    ping_count += 1
                    self.logger.info(f"Âü∑Ë°åÁ¨¨ {ping_count} Ê¨°‰øùÊ¥ªping...")
                    await self.keep_alive_ping()
            except asyncio.CancelledError:
                self.logger.info(f"‰øùÊ¥ª‰ªªÂãôÂ∑≤ÂèñÊ∂à (ÂÖ±Âü∑Ë°å‰∫Ü {ping_count} Ê¨°ping)")
                break
            except Exception as e:
                self.logger.error(f"‰øùÊ¥ª‰ªªÂãôÂá∫ÈåØ: {e}")
                await asyncio.sleep(60)  # ÈåØË™§ÊôÇÁ≠âÂæÖ1ÂàÜÈêòÂÜçË©¶

    def get_status(self) -> Dict[str, Any]:
        """Áç≤ÂèñÁ≥ªÁµ±ÁãÄÊÖã"""
        try:
            if self.stats['start_time'] and isinstance(self.stats['start_time'], datetime):
                runtime = datetime.now() - self.stats['start_time']
                runtime_seconds = int(runtime.total_seconds())
                runtime_formatted = str(runtime).split('.')[0]
            else:
                runtime_seconds = 0
                runtime_formatted = "0:00:00"
            
            # Á∞°ÂåñÁãÄÊÖãÈüøÊáâÔºåÈÅøÂÖçÂ∫èÂàóÂåñÂïèÈ°å
            return {
                'is_running': self.is_running,
                'runtime_seconds': runtime_seconds,
                'runtime_formatted': runtime_formatted,
                'stats': {
                    'alerts_sent': self.stats['alerts_sent'],
                    'checks_performed': self.stats['checks_performed'],
                    'errors_count': self.stats['errors_count'],
                    'start_time': self.stats['start_time'].isoformat() if self.stats['start_time'] and isinstance(self.stats['start_time'], datetime) else None
                },
                'monitoring_symbols': self.config['monitoring']['symbols'],
                'monitoring_active': len(self.monitoring_data) > 0,
                'keep_alive': {
                    'enabled': self.keep_alive_enabled,
                    'interval_seconds': self.keep_alive_interval,
                    'health_url': self.health_url,
                    'last_ping': self.last_keep_alive.isoformat() if self.last_keep_alive else None
                },
                'telegram_handlers': {
                    'webhook_active': bool(self.webhook_handler),
                    'polling_active': bool(self.interactive_handler)
                },
                'timestamp': datetime.now().isoformat()
            }
        except Exception as e:
            return {
                'status': 'error',
                'error': str(e),
                'is_running': self.is_running,
                'timestamp': datetime.now().isoformat()
            }

def main():
    """‰∏ªÂáΩÊï∏"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Èõ≤Á´ØMACDÁõ£ÊéßÁ≥ªÁµ±')
    parser.add_argument('--config', default='monitor_config.json', help='ÈÖçÁΩÆÊñá‰ª∂Ë∑ØÂæë')
    parser.add_argument('--test', action='store_true', help='Ê∏¨Ë©¶Ê®°Âºè')
    args = parser.parse_args()
    
    monitor = CloudMonitor(args.config)
    
    if args.test:
        print("üß™ Ê∏¨Ë©¶Ê®°Âºè")
        # ÂèØ‰ª•Ê∑ªÂä†Ê∏¨Ë©¶ÈÇèËºØ
        return
    
    try:
        asyncio.run(monitor.run_forever())
    except KeyboardInterrupt:
        print("\nüëã Áõ£ÊéßÁ≥ªÁµ±Â∑≤ÂÅúÊ≠¢")

if __name__ == "__main__":
    main() 